# Cook 模块重构计划

## 目标

将 `llm_path/cook.py` (~1000行) 重构为 `llm_path/cook/` 包，实现：
1. 每个 provider (OpenAI, Claude) 独立实现文件
2. 依赖分析独立模块
3. 保持公共 API 兼容性
4. **外层模块不感知 provider 原始数据细节**

## 新包结构

```
llm_path/
├── cook/
│   ├── __init__.py           # 公共 API: cook_traces(), TraceCooker
│   ├── models.py             # CookedMessage, CookedTool, CookedRequest, CookedOutput
│   ├── deduplicator.py       # MessageDeduplicator, ToolDeduplicator
│   ├── dependency.py         # DependencyAnalyzer (Levenshtein + tool matching)
│   ├── base.py               # BaseProvider 抽象基类
│   ├── providers/
│   │   ├── __init__.py       # detect_provider, get_provider, PROVIDERS
│   │   ├── openai.py         # OpenAIProvider (含 SSE 解析)
│   │   └── claude.py         # ClaudeProvider (含 SSE 解析)
│   └── cooker.py             # TraceCooker 协调器
└── cook.py                   # 删除 (功能移入 cook/)
```

## 设计原则

**外层模块只与抽象接口交互，不感知 provider 细节：**
- `cooker.py` 只调用 `provider.process_record()` 返回 `CookedRequest`
- `deduplicator.py` 只处理 `CookedMessage`/`CookedTool`
- `dependency.py` 只处理 `CookedRequest` 列表
- SSE 解析、格式检测等细节 **封装在各 provider 内部**

## 模块职责

| 模块 | 职责 | 是否感知 provider 细节 |
|------|------|------------------------|
| `models.py` | 数据类定义 | 否 |
| `deduplicator.py` | 消息/工具去重 (通过 hash) | 否 |
| `dependency.py` | 请求依赖分析 | 否 |
| `base.py` | Provider 接口定义 | 否 |
| `cooker.py` | 主流程协调 | 否 |
| `providers/openai.py` | OpenAI 格式处理 + SSE 解析 | **是 (内部)** |
| `providers/claude.py` | Claude 格式处理 + SSE 解析 | **是 (内部)** |

## 关键接口设计

### BaseProvider

```python
class BaseProvider(ABC):
    @staticmethod
    @abstractmethod
    def detect(record: dict) -> bool:
        """判断是否能处理此记录 (provider 内部实现)"""

    @abstractmethod
    def process_record(
        self,
        record: dict,
        message_dedup: MessageDeduplicator,
        tool_dedup: ToolDeduplicator,
    ) -> CookedRequest:
        """处理单条原始记录，返回标准化的 CookedRequest

        内部负责:
        - 格式检测
        - SSE 解析 (如果是流式响应)
        - 消息/工具提取
        外层只看到返回的 CookedRequest
        """
```

### MessageDeduplicator

```python
class MessageDeduplicator:
    def get_or_create(self, role, content, tool_calls, ...) -> str:
        """返回消息 ID (去重)

        接收已标准化的数据，不关心来源 provider
        """

    @property
    def messages(self) -> list[CookedMessage]:
        """返回所有去重后的消息"""
```

### DependencyAnalyzer

```python
class DependencyAnalyzer:
    def analyze(self, requests: list[CookedRequest]) -> None:
        """分析依赖并设置 parent_id (原地修改)

        只处理标准化的 CookedRequest，不关心来源 provider
        """
```

## 实现步骤

1. 创建 `cook/` 目录结构
2. 创建 `models.py` - 数据类
3. 创建 `deduplicator.py` - 去重逻辑 (含 hash 计算)
4. 创建 `dependency.py` - 依赖分析
5. 创建 `base.py` - Provider 基类
6. 创建 `providers/__init__.py` - provider 注册
7. 创建 `providers/openai.py` - OpenAI 实现 (含 SSE 解析)
8. 创建 `providers/claude.py` - Claude 实现 (含 SSE 解析)
9. 创建 `cooker.py` - TraceCooker
10. 创建 `__init__.py` - 公共 API
11. 删除旧的 `cook.py`
12. 验证 CLI 和 viewer 功能

## 需要修改的文件

- `llm_path/cook.py` → 删除，内容移入新包
- `llm_path/cli.py` → 无需修改 (import 路径保持兼容)
- `llm_path/viewer.py` → 无需修改 (import 路径保持兼容)

## 验证方式

```bash
# 验证 cook 命令
llm-path cook trace.jsonl -o output.json

# 验证 viewer 命令
llm-path viewer trace.jsonl

# 验证不同格式
llm-path cook openai-trace.jsonl -o out.json --format openai
llm-path cook claude-trace.jsonl -o out.json --format claude
```

## 扩展性

添加新 provider (如 Gemini)：
1. 创建 `providers/gemini.py` 实现 `BaseProvider`
   - 包含格式检测逻辑 (`detect`)
   - 包含消息/工具/响应解析逻辑
   - 包含 SSE 解析 (如果需要，作为内部实现)
2. 在 `providers/__init__.py` 注册到 `PROVIDERS` 列表
